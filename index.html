/*********************
 * ClassificationSandbox-komponenten *
 *********************/
function ClassificationSandbox({ trainingData, customWordCounts }) {
  const [inputText, setInputText] = React.useState("");
  const [result, setResult] = React.useState(null);
  const [useLaplace, setUseLaplace] = React.useState(true);
  const [loading, setLoading] = React.useState(false);

  const classifyEmail = () => {
    setLoading(true);
    setTimeout(() => {
      const words = inputText.toLowerCase().match(/\b\w+\b/g) || [];
      const spamEmails = trainingData.filter(email => email.label === "spam");
      const hamEmails = trainingData.filter(email => email.label === "ham");
      const spamCount = spamEmails.length;
      const hamCount = hamEmails.length;

      if (spamCount === 0 || hamCount === 0) {
        alert("Det måste finnas både spam och icke-spam i träningsdata!");
        setLoading(false);
        return;
      }
      
      if(words.length === 0) {
        setResult({
          error: "Inga ord att klassificera! Lägg till text i e-postmeddelandet."
        });
        setLoading(false);
        return;
      }

      const computedSpamCounts = computeWordCounts(spamEmails);
      const computedHamCounts = computeWordCounts(hamEmails);
      const vocabulary = new Set();
      trainingData.forEach(email => {
        (email.text.toLowerCase().match(/\b\w+\b/g) || []).forEach(token => vocabulary.add(token));
      });
      const vocabSize = vocabulary.size;

      let spamProb = Math.log(spamCount / trainingData.length);
      let hamProb = Math.log(hamCount / trainingData.length);
      const details = [];

      words.forEach(word => {
        const countSpam = customWordCounts[word]?.spam !== undefined ? customWordCounts[word].spam : (computedSpamCounts[word] || 0);
        const countHam = customWordCounts[word]?.ham !== undefined ? customWordCounts[word].ham : (computedHamCounts[word] || 0);
        const laplaceAdjust = useLaplace ? 1 : 0;
        const adjustedVocab = useLaplace ? vocabSize : 0;
        const probWordSpam = (countSpam + laplaceAdjust) / (spamCount + adjustedVocab);
        const probWordHam = (countHam + laplaceAdjust) / (hamCount + adjustedVocab);
        spamProb += Math.log(probWordSpam);
        hamProb += Math.log(probWordHam);
        details.push({ word, probWordSpam, probWordHam, countSpam, countHam });
      });

      const finalLabel = spamProb > hamProb ? "Spam" : "Icke-Spam";
      setResult({ spamProb, hamProb, details, finalLabel });
      setLoading(false);
    }, 500);
  };

  return (
    <section>
      <h2>Sandlådeläge för Klassificering</h2>
      <textarea
        aria-label="Skriv e-post för klassificering"
        rows="4"
        placeholder="Skriv en e-post här..."
        value={inputText}
        onChange={(e) => setInputText(e.target.value)}
        // Tillåt horisontell ändring genom att ta bort max-width-begränsningen
        style={{ resize: "horizontal", maxWidth: "none" }}
      ></textarea>
      <br />
      <label>
        <input 
          type="checkbox" 
          checked={useLaplace} 
          onChange={(e) => setUseLaplace(e.target.checked)} 
        />{" "}
        Använd Laplace-utjämning
      </label>
      <br />
      <button onClick={classifyEmail}>
        <i className="fas fa-magic"></i> Klassificera
      </button>
      {loading && <p><i className="fas fa-spinner fa-spin"></i> Laddar...</p>}
      <p>
        Antal spam-mail: {trainingData.filter(e => e.label==="spam").length} | Antal icke-spam: {trainingData.filter(e => e.label==="ham").length}
      </p>
      {result && (
        <div>
          <h3>Resultat:</h3>
          {result.error ? (
            <p className="warning">{result.error}</p>
          ) : (
            <>
              <p>
                Sannolikhet Spam: {Math.exp(result.spamProb).toExponential(2)}<br />
                (Log: {result.spamProb.toFixed(3)})
              </p>
              <p>
                Sannolikhet Icke-Spam: {Math.exp(result.hamProb).toExponential(2)}<br />
                (Log: {result.hamProb.toFixed(3)})
              </p>
              <p>
                Klassificering: <strong>{result.finalLabel}</strong>
              </p>
              <h4>Detaljer per ord:</h4>
              <ul>
                {result.details.map((d, i) => (
                  <li key={i}>
                    Ordet "<em>{d.word}</em>" – P(word|Spam): {d.probWordSpam.toFixed(3)}
                    {d.countSpam === 0 && <span className="warning"> (OBS! Noll på spam)</span>},&nbsp;
                    P(word|Icke-Spam): {d.probWordHam.toFixed(3)}
                    {d.countHam === 0 && <span className="warning"> (OBS! Noll på icke-spam)</span>}
                  </li>
                ))}
              </ul>
            </>
          )}
        </div>
      )}
    </section>
  );
}
