<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <title>Interaktiv Naive Bayes Demo</title>
    <!-- Font Awesome för ikoner -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- Babel Standalone version 7 -->
    <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>
    <!-- D3.js (för framtida visualiseringar) -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Ta bort d3 från global scope -->
    <script> delete window.d3; </script>
    <!-- MathLive (för LaTeX-rendering) -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/mathlive/0.69.4/mathlive.min.css"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/mathlive/0.69.4/mathlive.min.js"
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <style>
      /* Grundläggande typografi och färgpalett */
      body {
        font-family: 'Segoe UI', system-ui, sans-serif;
        line-height: 1.6;
        margin: 20px;
        color: #2c3e50;
        background: #f7f7f7;
      }
      h1 {
        font-size: 2.2rem;
        color: #2c3e50;
        border-bottom: 3px solid #3498db;
        padding-bottom: 0.5rem;
        margin-bottom: 1rem;
      }
      h2 {
        font-size: 1.5rem;
        color: #3498db;
        margin-bottom: 1rem;
      }
      h3, h4 {
        color: #2c3e50;
      }
      /* Sektioner med extra padding */
      section {
        padding: 1.5rem;
        margin-bottom: 2rem;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
      /* Tvåkolumnslayout */
      .two-column {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }
      @media (max-width: 768px) {
        .two-column {
          grid-template-columns: 1fr;
        }
      }
      /* Tabeller och formulär */
      table {
        width: 100%;
        overflow-x: auto;
        display: block;
        border-collapse: collapse;
        margin: 10px 0;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        transition: background-color 0.2s ease;
      }
      th, td {
        border: 1px solid #aaa;
        padding: 5px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
      }
      /* Alternerande radfärger */
      tr:nth-child(even) {
        background-color: #f9f9f9;
      }
      tr:hover {
        background-color: #f8f9fa;
      }
      input[type="text"],
      input[type="number"],
      select,
      textarea {
        max-width: 100%;
        box-sizing: border-box;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      .input-full {
        width: 100%;
      }
      /* Knappar med hover- och klick-effekter */
      button {
        background: #3498db;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 5px 10px;
        font-size: 1em;
        transition: background 0.3s ease, transform 0.1s ease;
        cursor: pointer;
      }
      button:hover {
        background: #2980b9;
      }
      button:active {
        transform: scale(0.98);
      }
      .edit-btn {
        font-size: 0.8em;
        margin-left: 5px;
      }
      /* Varningstext */
      .warning {
        color: #e74c3c;
      }
      /* Färgkodade badges för labels */
      .spam-badge {
        background: #e74c3c;
        color: white;
        padding: 2px 5px;
        border-radius: 3px;
      }
      .ham-badge {
        background: #2ecc71;
        color: white;
        padding: 2px 5px;
        border-radius: 3px;
      }
      /* Redigeringsfält */
      .editable {
        background-color: #eef;
        box-shadow: 0 0 3px rgba(52, 152, 219, 0.5);
      }
      /* Interaktivt stapeldiagram */
      .bar-container {
        display: flex;
        gap: 2px;
        transition: height 0.3s ease;
        min-height: 30px;
      }
      .spam-bar {
        background-color: #e74c3c;
        transition: width 0.3s ease;
      }
      .ham-bar {
        background-color: #2ecc71;
        transition: width 0.3s ease;
      }
      /* Mobilanpassning: döljer stapeldiagramkolumnen vid små skärmar */
      @media (max-width: 480px) {
        .two-column {
          gap: 10px;
        }
        table th:nth-child(4),
        table td:nth-child(4) {
          display: none;
        }
      }
      /* Tooltip-effekt vid hover */
      .tooltip {
        position: relative;
      }
      .tooltip:hover::after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        white-space: nowrap;
      }
      /* Interaktiv Bayes-formel */
      .formula-container {
        margin-bottom: 1rem;
      }
      .formula-part {
        cursor: pointer;
        padding: 2px 5px;
        border-radius: 3px;
        transition: background 0.2s;
      }
      .formula-part:hover {
        background: #3498db33;
      }
      /* Guided Tour */
      .tour {
        background: #f2f2f2;
        padding: 1rem;
        border-radius: 5px;
        margin-bottom: 1rem;
      }
      /* Live-förhandsvisning av P(Spam) */
      .spam-probability {
        font-weight: bold;
        margin-bottom: 1rem;
      }
      /* Stil för att visa utökade beräkningsdetaljer */
      .calculation-details {
        font-family: monospace;
        background: #f0f0f0;
        padding: 0.5rem;
        border-radius: 5px;
        margin-top: 1rem;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    
    <!-- Sätter React och ReactDOM i global scope -->
    <script>
      window.React = React;
      window.ReactDOM = ReactDOM;
    </script>
    
    <!-- All React-kod skrivs med Babel (JSX) -->
    <script type="text/babel" data-presets="react,es2015">
      /* @jsx React.createElement */
      
      /********************
       * Hjälpfunktioner *
       ********************/
      function computeWordCounts(emails) {
        const counts = {};
        emails.forEach((email) => {
          const tokens = email.text.toLowerCase().match(/\b\w+\b/g) || [];
          tokens.forEach((token) => {
            counts[token] = (counts[token] || 0) + 1;
          });
        });
        return counts;
      }
      
      /*********************
       * Latex-komponenten *
       *********************/
      function Latex({ children }) {
        // MathLive renderar LaTeX-strängen till HTML
        const markup = MathLive.renderToMarkup(children);
        return <div dangerouslySetInnerHTML={{ __html: markup }} />;
      }
      
      /**************************
       * InteractiveFormula-komponenten *
       **************************/
      function InteractiveFormula({ parts, onPartClick }) {
        return (
          <div className="formula-container">
            {parts.map((part, i) => (
              <span 
                key={i}
                className="formula-part tooltip"
                title={part.tooltip}
                onClick={() => onPartClick(part)}
              >
                {part.label}
              </span>
            ))}
          </div>
        );
      }
      
      /**************************
       * GuidedTour-komponenten *
       **************************/
      function GuidedTour() {
        return (
          <div className="tour">
            <h3>Välkommen till Naive Bayes-simulatorn!</h3>
            <ol>
              <li>Ladda träningsdata från filen <code>trainingData.json</code></li>
              <li>Justera ordfrekvenser i ordfrekvenstabellen</li>
              <li>Testa klassificering i sandlådeläget nedan</li>
            </ol>
          </div>
        );
      }
      
      /**************************
       * WordFrequencyRow-komponenten *
       **************************/
      function WordFrequencyRow({ word, spamCount, hamCount, editing, onEdit, onSave, onCancel, editSpam, editHam, setEditSpam, setEditHam, totalSpamWords, totalHamWords, vocabSize }) {
        const total = spamCount + hamCount;
        const spamPercentage = total > 0 ? (spamCount / total) * 100 : 0;
        const hamPercentage = total > 0 ? (hamCount / total) * 100 : 0;
        const totalHeight = Math.log(total + 1) * 10;
        // Använd Laplace endast om count är 0, annars använd den "råa" frekvensen
        const pWordSpam = spamCount === 0 
          ? ((spamCount + 1) / (totalSpamWords + vocabSize)).toFixed(3)
          : (spamCount / totalSpamWords).toFixed(3);
        const pWordHam = hamCount === 0 
          ? ((hamCount + 1) / (totalHamWords + vocabSize)).toFixed(3)
          : (hamCount / totalHamWords).toFixed(3);
        return (
          <tr>
            <td>{word}</td>
            <td>
              {editing ? (
                <input
                  aria-label={`Redigera spam-värde för ${word}`}
                  type="number"
                  className="editable"
                  value={editSpam}
                  onChange={(e) => setEditSpam(e.target.value)}
                />
              ) : (
                <>
                  {spamCount}
                  {Number(spamCount) === 0 && <span className="warning"> (OBS! Noll)</span>}
                </>
              )}
            </td>
            <td>
              {editing ? (
                <input
                  aria-label={`Redigera ham-värde för ${word}`}
                  type="number"
                  className="editable"
                  value={editHam}
                  onChange={(e) => setEditHam(e.target.value)}
                />
              ) : (
                <>
                  {hamCount}
                  {Number(hamCount) === 0 && <span className="warning"> (OBS! Noll)</span>}
                </>
              )}
            </td>
            <td>
              <div className="bar-container" style={{ height: `${totalHeight}px` }} title={`Spam: ${spamCount}, Icke-spam: ${hamCount}`}>
                <div className="spam-bar" style={{ width: `${spamPercentage}%` }}></div>
                <div className="ham-bar" style={{ width: `${hamPercentage}%` }}></div>
              </div>
            </td>
            <td>{pWordSpam}</td>
            <td>{pWordHam}</td>
            <td>
              {editing ? (
                <>
                  <button className="edit-btn" onClick={() => onSave(word)}>Spara</button>
                  <button className="edit-btn" onClick={onCancel}>Avbryt</button>
                </>
              ) : (
                <button className="edit-btn" onClick={() => onEdit(word)}>Redigera</button>
              )}
            </td>
          </tr>
        );
      }
      
      /*********************
       * BayesFormula-komponenten *
       *********************/
      function BayesFormula() {
        return (
          <div>
            <h2>Interaktiv Bayes-formel</h2>
            <Latex>{'$$P(Spam|Ord)=\\frac{P(Ord|Spam)\\cdot P(Spam)}{P(Ord)}$$'}</Latex>
            <InteractiveFormula 
              parts={[
                { label: "P(Spam|Ord)", tooltip: "Sannolikheten att ett mail är spam givet ett ord" },
                { label: "=", tooltip: "Likhetstecken" },
                { label: "P(Ord|Spam)", tooltip: "Sannolikheten att ordet förekommer om mailet är spam" },
                { label: "×", tooltip: "Multiplikation" },
                { label: "P(Spam)", tooltip: "Andelen mail som är spam" },
                { label: "/", tooltip: "Division" },
                { label: "P(Ord)", tooltip: "Sannolikheten att ordet förekommer" }
              ]}
              onPartClick={(part) => alert(`Du klickade på "${part.label}". ${part.tooltip}`)}
            />
            <p>Klicka på en del av formeln för att se mer information.</p>
          </div>
        );
      }
      
      /*********************
       * TrainingData-komponenten *
       *********************/
      function TrainingData({ data, updateData }) {
        const [newEmailText, setNewEmailText] = React.useState("");
        const [newEmailLabel, setNewEmailLabel] = React.useState("spam");
      
        const addEmail = () => {
          if(newEmailText.trim() === "") {
            alert("E-posttext får inte vara tom!");
            return;
          }
          const newId = data.length ? Math.max(...data.map(e => e.id)) + 1 : 1;
          updateData([...data, { id: newId, text: newEmailText, label: newEmailLabel }]);
          setNewEmailText("");
        };
      
        const handleTextChange = (id, field, value) => {
          const newData = data.map((email) =>
            email.id === id ? { ...email, [field]: value } : email
          );
          updateData(newData);
        };
      
        return (
          <section>
            <h2>Interaktiv Träningsdata</h2>
            <p>Visar endast de första 10 av {data.length} e-postmeddelanden.</p>
            <table className="input-table">
              <thead>
                <tr>
                  <th scope="col">ID</th>
                  <th scope="col">Text</th>
                  <th scope="col">Label</th>
                </tr>
              </thead>
              <tbody>
                {data.slice(0,10).map((email) => (
                  <tr key={email.id}>
                    <td>{email.id}</td>
                    <td>
                      <input
                        aria-label={`Redigera text för e-post ${email.id}`}
                        type="text"
                        className="input-full"
                        value={email.text}
                        onChange={(e) => handleTextChange(email.id, "text", e.target.value)}
                      />
                    </td>
                    <td>
                      <select
                        aria-label={`Ändra label för e-post ${email.id}`}
                        value={email.label}
                        onChange={(e) => handleTextChange(email.id, "label", e.target.value)}
                      >
                        <option value="spam" style={{ backgroundColor: '#e74c3c22' }}>Spam</option>
                        <option value="ham" style={{ backgroundColor: '#2ecc7122' }}>Icke-Spam</option>
                      </select>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            <div style={{ marginTop: "10px" }}>
              <h4>Lägg till e-post</h4>
              <textarea
                aria-label="Ny e-posttext"
                rows="2"
                className="input-full"
                placeholder="Skriv e-posttext här..."
                value={newEmailText}
                onChange={(e) => setNewEmailText(e.target.value)}
              ></textarea>
              <div>
                <label>
                  Label:{" "}
                  <select
                    aria-label="Välj label"
                    value={newEmailLabel}
                    onChange={(e) => setNewEmailLabel(e.target.value)}
                  >
                    <option value="spam" style={{ backgroundColor: '#e74c3c22' }}>Spam</option>
                    <option value="ham" style={{ backgroundColor: '#2ecc7122' }}>Icke-Spam</option>
                  </select>
                </label>
              </div>
              <button onClick={addEmail}><i className="fas fa-plus"></i> Lägg till e-post</button>
            </div>
          </section>
        );
      }
      
      /*********************
       * WordFrequencyTable-komponenten *
       *********************/
      function WordFrequencyTable({ trainingData, customWordCounts, setCustomWordCounts }) {
        const spamEmails = trainingData.filter(email => email.label === "spam");
        const hamEmails = trainingData.filter(email => email.label === "ham");
      
        const computedSpamCounts = React.useMemo(() => computeWordCounts(spamEmails), [spamEmails]);
        const computedHamCounts = React.useMemo(() => computeWordCounts(hamEmails), [hamEmails]);
      
        // Hämta vokabulär (alla unika ord) från både beräknad och manuellt justerad data
        const vocabulary = new Set([
          ...Object.keys(computedSpamCounts),
          ...Object.keys(computedHamCounts),
          ...Object.keys(customWordCounts)
        ]);
        const vocabSize = vocabulary.size;
        const totalSpamWords = Object.values(computedSpamCounts).reduce((sum, val) => sum + val, 0);
        const totalHamWords = Object.values(computedHamCounts).reduce((sum, val) => sum + val, 0);
      
        const allWords = Array.from(vocabulary).sort();
      
        const [editingWord, setEditingWord] = React.useState(null);
        const [editSpam, setEditSpam] = React.useState(0);
        const [editHam, setEditHam] = React.useState(0);
        const [newWord, setNewWord] = React.useState("");
        const [newSpam, setNewSpam] = React.useState(0);
        const [newHam, setNewHam] = React.useState(0);
      
        const handleEdit = (word) => {
          setEditingWord(word);
          setEditSpam(customWordCounts[word]?.spam ?? computedSpamCounts[word] ?? 0);
          setEditHam(customWordCounts[word]?.ham ?? computedHamCounts[word] ?? 0);
        };
      
        const saveEdit = (word) => {
          if(editSpam < 0 || editHam < 0) {
            alert("Talen måste vara ≥ 0");
            return;
          }
          setCustomWordCounts({
            ...customWordCounts,
            [word]: { spam: Number(editSpam), ham: Number(editHam) }
          });
          setEditingWord(null);
        };
      
        const cancelEdit = () => {
          setEditingWord(null);
        };
      
        const handleAddNewWord = () => {
          if(newWord.trim() === "" || newSpam < 0 || newHam < 0) {
            alert("Ogiltig input! Ord får inte vara tomma och tal måste vara ≥ 0");
            return;
          }
          setCustomWordCounts({
            ...customWordCounts,
            [newWord.toLowerCase()]: { spam: Number(newSpam), ham: Number(newHam) }
          });
          setNewWord("");
          setNewSpam(0);
          setNewHam(0);
        };
      
        return (
          <section>
            <h2>Ordfrekvenstabell</h2>
            <table>
              <thead>
                <tr>
                  <th scope="col">Ord</th>
                  <th scope="col">Spam</th>
                  <th scope="col">Icke-Spam</th>
                  <th scope="col">Visual</th>
                  <th scope="col">P(word|Spam)</th>
                  <th scope="col">P(word|Icke-Spam)</th>
                  <th scope="col">Åtgärd</th>
                </tr>
              </thead>
              <tbody>
                {allWords.map((word) => {
                  const spamCount = customWordCounts[word]?.spam ?? computedSpamCounts[word] ?? 0;
                  const hamCount = customWordCounts[word]?.ham ?? computedHamCounts[word] ?? 0;
                  return (
                    <WordFrequencyRow
                      key={word}
                      word={word}
                      spamCount={spamCount}
                      hamCount={hamCount}
                      editing={editingWord === word}
                      onEdit={handleEdit}
                      onSave={saveEdit}
                      onCancel={cancelEdit}
                      editSpam={editSpam}
                      editHam={editHam}
                      setEditSpam={setEditSpam}
                      setEditHam={setEditHam}
                      totalSpamWords={totalSpamWords}
                      totalHamWords={totalHamWords}
                      vocabSize={vocabSize}
                    />
                  );
                })}
              </tbody>
            </table>
            <h4>Lägg till nytt ord</h4>
            <div>
              <input
                aria-label="Nytt ord"
                type="text"
                placeholder="Ord"
                value={newWord}
                onChange={(e) => setNewWord(e.target.value)}
              />
              <input
                aria-label="Nytt spam-värde"
                type="number"
                placeholder="Spam"
                value={newSpam}
                onChange={(e) => setNewSpam(e.target.value)}
              />
              <input
                aria-label="Nytt ham-värde"
                type="number"
                placeholder="Icke-Spam"
                value={newHam}
                onChange={(e) => setNewHam(e.target.value)}
              />
              <button onClick={handleAddNewWord}><i className="fas fa-plus"></i> Lägg till</button>
            </div>
            <p>Om du manuellt redigerar värdena i denna tabell används dessa istället för de automatiskt beräknade frekvenserna.</p>
          </section>
        );
      }
      
      /*********************
       * ClassificationSandbox-komponenten *
       *********************/
      function ClassificationSandbox({ trainingData, customWordCounts }) {
        const [inputText, setInputText] = React.useState("");
        const [result, setResult] = React.useState(null);
        const [useLaplace, setUseLaplace] = React.useState(true);
        const [loading, setLoading] = React.useState(false);
        const [calculation, setCalculation] = React.useState("");
      
        const classifyEmail = () => {
          setLoading(true);
          setCalculation("");
          setTimeout(() => {
            const words = inputText.toLowerCase().match(/\b\w+\b/g) || [];
            const spamEmails = trainingData.filter(email => email.label === "spam");
            const hamEmails = trainingData.filter(email => email.label === "ham");
            const spamCount = spamEmails.length;
            const hamCount = hamEmails.length;
      
            if (spamCount === 0 || hamCount === 0) {
              alert("Det måste finnas både spam och icke-spam i träningsdata!");
              setLoading(false);
              return;
            }
            
            if (words.length === 0) {
              setResult({
                error: "Inga ord att klassificera! Lägg till text i e-postmeddelandet."
              });
              setLoading(false);
              return;
            }
      
            const computedSpamCounts = computeWordCounts(spamEmails);
            const computedHamCounts = computeWordCounts(hamEmails);
            const vocabulary = new Set();
            trainingData.forEach(email => {
              (email.text.toLowerCase().match(/\b\w+\b/g) || []).forEach(token => vocabulary.add(token));
            });
            const vocabSize = vocabulary.size;
      
            // Prior sannolikheter
            const priorSpam = spamCount / trainingData.length;
            const priorHam = hamCount / trainingData.length;
      
            let prodSpam = 1;
            let prodHam = 1;
            let calcDetails = `Prior Spam: ${priorSpam.toFixed(3)}\nPrior Icke-Spam: ${priorHam.toFixed(3)}\n\n`;
      
            words.forEach(word => {
              const countSpam = customWordCounts[word]?.spam !== undefined ? customWordCounts[word].spam : (computedSpamCounts[word] || 0);
              const countHam = customWordCounts[word]?.ham !== undefined ? customWordCounts[word].ham : (computedHamCounts[word] || 0);
      
              // Om count är 0, använd Laplace (dvs. lägg till 1 och addera vokabulärstorlek i nämnaren), annars använd "råa" frekvensen
              const pWordSpam = countSpam === 0 
                ? (countSpam + 1) / (spamCount + vocabSize)
                : countSpam / spamCount;
              const pWordHam = countHam === 0 
                ? (countHam + 1) / (hamCount + vocabSize)
                : countHam / hamCount;
      
              prodSpam *= pWordSpam;
              prodHam *= pWordHam;
      
              calcDetails += `Ord: ${word}\n  Spam: count=${countSpam}, p=${pWordSpam.toFixed(3)}\n  Icke-Spam: count=${countHam}, p=${pWordHam.toFixed(3)}\n\n`;
            });
      
            // Bayes-formeln: P(Spam|Ord) = [P(Ord|Spam)*P(Spam)] / [P(Ord|Spam)*P(Spam) + P(Ord|Icke-Spam)*P(Icke-Spam)]
            const numerator = priorSpam * prodSpam;
            const denominator = numerator + (priorHam * prodHam);
            const finalProb = numerator / denominator;
      
            calcDetails += `Numerator: ${priorSpam.toFixed(3)} × ${prodSpam.toExponential(3)} = ${numerator.toExponential(3)}\n`;
            calcDetails += `Denominator: ${numerator.toExponential(3)} + ${ (priorHam * prodHam).toExponential(3) } = ${denominator.toExponential(3)}\n`;
            calcDetails += `P(Spam|Ord) = ${finalProb.toExponential(3)}`;
      
            setResult({ finalProb });
            setCalculation(calcDetails);
            setLoading(false);
          }, 500);
        };
      
        return (
          <section>
            <h2>Sandlådeläge för Klassificering</h2>
            <textarea
              aria-label="Skriv e-post för klassificering"
              rows="4"
              placeholder="Skriv en e-post här..."
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
            ></textarea>
            <br />
            <label>
              <input 
                type="checkbox" 
                checked={useLaplace} 
                onChange={(e) => setUseLaplace(e.target.checked)} 
              />{" "}
              Använd Laplace-utjämning (endast om värdet är 0)
            </label>
            <br />
            <button onClick={classifyEmail}>
              <i className="fas fa-magic"></i> Klassificera
            </button>
            {loading && <p><i className="fas fa-spinner fa-spin"></i> Laddar...</p>}
            <p>
              Antal spam-mail: {trainingData.filter(e => e.label==="spam").length} | Antal icke-spam: {trainingData.filter(e => e.label==="ham").length}
            </p>
            {result && (
              <div>
                <h3>Resultat:</h3>
                {result.error ? (
                  <p className="warning">{result.error}</p>
                ) : (
                  <>
                    <p>P(Spam|Ord) = {result.finalProb.toExponential(3)}</p>
                    <div className="calculation-details">
                      {calculation}
                    </div>
                  </>
                )}
              </div>
            )}
          </section>
        );
      }
      
      /*********************
       * Gamification-komponenten *
       *********************/
      function Gamification() {
        return (
          <section>
            <h2>Spelifiering</h2>
            <p>
              Utmaning: Försök att klassificera en e-post korrekt genom att justera din träningsdata eller ändra ordfrekvenserna!
            </p>
            <p>
              Felanalys: Om du ignorerar Laplace-utjämning (d.v.s. om ordets count är 0) används istället en utjämning vilket påverkar resultatet.
            </p>
          </section>
        );
      }
      
      /*********************
       * Huvudkomponenten: App *
       *********************/
      function App() {
        const [trainingData, setTrainingData] = React.useState([]);
        const [customWordCounts, setCustomWordCounts] = React.useState({
          "gratis": { spam: 3, ham: 0 },
          "vinst": { spam: 2, ham: 0 },
          "vinn": { spam: 2, ham: 0 },
          "hej": { spam: 0, ham: 3 },
          "möte": { spam: 0, ham: 2 }
        });
      
        // Hämta träningsdata från en extern JSON-fil (samma mapp)
        React.useEffect(() => {
          fetch("trainingData.json")
            .then((response) => response.json())
            .then((data) => {
              setTrainingData(data);
            })
            .catch((error) => {
              console.error("Fel vid hämtning av träningsdata:", error);
            });
        }, []);
      
        const spamProbability = trainingData.length > 0 
          ? trainingData.filter(e => e.label==="spam").length / trainingData.length 
          : 0;
      
        return (
          <div>
            <h1>Interaktiv Naive Bayes Demo</h1>
            <GuidedTour />
            <BayesFormula />
            <div className="spam-probability">Aktuell P(Spam): {spamProbability.toFixed(2)}</div>
            <hr />
            <div className="two-column">
              <TrainingData data={trainingData} updateData={setTrainingData} />
              <WordFrequencyTable 
                trainingData={trainingData} 
                customWordCounts={customWordCounts} 
                setCustomWordCounts={setCustomWordCounts} 
              />
            </div>
            <hr />
            <ClassificationSandbox trainingData={trainingData} customWordCounts={customWordCounts} />
            <hr />
            <Gamification />
          </div>
        );
      }
      
      ReactDOM.render(<App />, document.getElementById("root"));
    </script>
  </body>
</html> 
